# Dashboard Grid Layout Implementation Guide

## Overview

This document provides a complete implementation guide for building a customizable dashboard with adjustable widgets. The dashboard features:

- **Drag-and-drop widget repositioning**
- **Resizable widgets**
- **Add/remove widgets from a catalog**
- **Persistent layout preferences**
- **Responsive design (mobile, tablet, desktop)**
- **Multiple widget types (KPIs, charts)**

## Technology Stack

- **React 18+** with TypeScript
- **react-grid-layout** for drag-and-drop grid
- **Recharts** for data visualization
- **TanStack Query** for data fetching and caching
- **Tailwind CSS** for styling
- **shadcn/ui** for UI components

## Installation

```bash
npm install react-grid-layout recharts @tanstack/react-query date-fns lucide-react
npm install --save-dev @types/react-grid-layout
```

## Core Data Structures

### Widget Type Definition

```typescript
type WidgetType = 'kpi' | 'line-chart' | 'bar-chart' | 'pie-chart' | 'area-chart' | 'stacked-bar-chart';

interface Widget {
  i: string;              // Unique identifier
  x: number;              // Grid X position
  y: number;              // Grid Y position
  w: number;              // Grid width (out of 24 columns)
  h: number;              // Grid height (in 60px units)
  type: WidgetType;       // Widget type
  title: string;          // Display title
  metric?: string;        // For KPI widgets
  dataSource?: string;    // For chart widgets
  category?: string;      // Category for organization
}

interface WidgetTemplate {
  type: WidgetType;
  title: string;
  description: string;
  defaultSize: { w: number; h: number };
  icon: React.ComponentType<{ className?: string }>;
  metric?: string;
  dataSource?: string;
  category: string;
}
```

## Widget Catalog

Create a comprehensive catalog of available widgets:

```typescript
import { Activity, Mail, Phone, Users, TrendingUp, Target, Clock, 
         FileText, CheckCircle, AlertTriangle, MousePointer, 
         CalendarDays, BarChart3, LineChart as LineChartIcon, 
         PieChart as PieChartIcon } from 'lucide-react';

const widgetCatalog: WidgetTemplate[] = [
  // KPI Widgets
  {
    type: 'kpi',
    title: 'Total Revenue',
    description: 'Total revenue across all deals',
    defaultSize: { w: 6, h: 2 },
    icon: Activity,
    metric: 'totalRevenue',
    category: 'Finance',
  },
  {
    type: 'kpi',
    title: 'Active Users',
    description: 'Number of active users',
    defaultSize: { w: 6, h: 2 },
    icon: Users,
    metric: 'activeUsers',
    category: 'Users',
  },
  {
    type: 'kpi',
    title: 'Conversion Rate',
    description: 'Percentage of conversions',
    defaultSize: { w: 6, h: 2 },
    icon: Target,
    metric: 'conversionRate',
    category: 'Conversion',
  },
  
  // Chart Widgets
  {
    type: 'line-chart',
    title: 'Revenue Trend',
    description: 'Revenue over time',
    defaultSize: { w: 12, h: 4 },
    icon: LineChartIcon,
    dataSource: 'revenue-trend',
    category: 'Finance',
  },
  {
    type: 'bar-chart',
    title: 'Monthly Sales',
    description: 'Sales by month',
    defaultSize: { w: 12, h: 4 },
    icon: BarChart3,
    dataSource: 'monthly-sales',
    category: 'Sales',
  },
  {
    type: 'pie-chart',
    title: 'Customer Segments',
    description: 'Distribution by segment',
    defaultSize: { w: 12, h: 4 },
    icon: PieChartIcon,
    dataSource: 'customer-segments',
    category: 'Users',
  },
];
```

## Default Layout

```typescript
const defaultLayout: Widget[] = [
  { i: 'revenue-1', x: 0, y: 0, w: 6, h: 2, type: 'kpi', title: 'Total Revenue', metric: 'totalRevenue', category: 'Finance' },
  { i: 'users-1', x: 6, y: 0, w: 6, h: 2, type: 'kpi', title: 'Active Users', metric: 'activeUsers', category: 'Users' },
  { i: 'conversion-1', x: 12, y: 0, w: 6, h: 2, type: 'kpi', title: 'Conversion Rate', metric: 'conversionRate', category: 'Conversion' },
  { i: 'revenue-trend', x: 0, y: 2, w: 12, h: 4, type: 'line-chart', title: 'Revenue Trend', dataSource: 'revenue-trend', category: 'Finance' },
  { i: 'monthly-sales', x: 12, y: 2, w: 12, h: 4, type: 'bar-chart', title: 'Monthly Sales', dataSource: 'monthly-sales', category: 'Sales' },
];
```

## Dashboard Component Implementation

```typescript
import React, { useState, useMemo, useRef, useEffect, useCallback } from 'react';
import GridLayout from 'react-grid-layout';
import 'react-grid-layout/css/styles.css';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogDescription, DialogHeader, 
         DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, 
         AlertDialogContent, AlertDialogDescription, AlertDialogFooter, 
         AlertDialogHeader, AlertDialogTitle } from '@/components/ui/alert-dialog';
import { Select, SelectContent, SelectItem, SelectTrigger, 
         SelectValue } from '@/components/ui/select';
import { GripVertical, Plus, X, RotateCcw, Maximize2, Minimize2 } from 'lucide-react';
import { toast } from 'sonner';

export default function Dashboard() {
  const [layout, setLayout] = useState<Widget[]>(defaultLayout);
  const [containerWidth, setContainerWidth] = useState(1200);
  const [addWidgetOpen, setAddWidgetOpen] = useState(false);
  const [widgetToDelete, setWidgetToDelete] = useState<string | null>(null);
  const [selectedCategory, setSelectedCategory] = useState<string>('all');
  const containerRef = useRef<HTMLDivElement>(null);

  // Responsive breakpoints
  const useIsMobile = () => {
    const [isMobile, setIsMobile] = useState(false);
    useEffect(() => {
      const checkMobile = () => setIsMobile(window.innerWidth < 768);
      checkMobile();
      window.addEventListener('resize', checkMobile);
      return () => window.removeEventListener('resize', checkMobile);
    }, []);
    return isMobile;
  };

  const useIsTablet = () => {
    const [isTablet, setIsTablet] = useState(false);
    useEffect(() => {
      const checkTablet = () => {
        const width = window.innerWidth;
        setIsTablet(width >= 768 && width < 1024);
      };
      checkTablet();
      window.addEventListener('resize', checkTablet);
      return () => window.removeEventListener('resize', checkTablet);
    }, []);
    return isTablet;
  };

  const isMobile = useIsMobile();
  const isTablet = useIsTablet();
  const cols = isMobile ? 8 : isTablet ? 16 : 24;

  // Update container width on resize
  useEffect(() => {
    const updateWidth = () => {
      if (containerRef.current) {
        setContainerWidth(containerRef.current.offsetWidth);
      }
    };
    updateWidth();
    window.addEventListener('resize', updateWidth);
    return () => window.removeEventListener('resize', updateWidth);
  }, []);

  // Handle layout changes
  const onLayoutChange = useCallback((newLayout: any[]) => {
    const updatedLayout = layout.map((widget) => {
      const layoutItem = newLayout.find(item => item.i === widget.i);
      if (layoutItem) {
        return {
          ...widget,
          x: layoutItem.x,
          y: layoutItem.y,
          w: layoutItem.w,
          h: layoutItem.h,
        };
      }
      return widget;
    });
    setLayout(updatedLayout);
    saveLayout(updatedLayout);
  }, [layout]);

  // Save layout to backend/localStorage
  const saveLayout = (layoutToSave: Widget[]) => {
    // Implement your persistence logic here
    localStorage.setItem('dashboardLayout', JSON.stringify(layoutToSave));
    console.log('Layout saved:', layoutToSave);
  };

  // Add widget from catalog
  const addWidget = (template: WidgetTemplate) => {
    const newId = `widget-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const maxY = layout.reduce((max, widget) => Math.max(max, widget.y + widget.h), 0);
    
    const newWidget: Widget = {
      i: newId,
      x: 0,
      y: maxY,
      w: template.defaultSize.w,
      h: template.defaultSize.h,
      type: template.type,
      title: template.title,
      metric: template.metric,
      dataSource: template.dataSource,
      category: template.category,
    };
    
    const newLayout = [...layout, newWidget];
    setLayout(newLayout);
    setAddWidgetOpen(false);
    saveLayout(newLayout);
    toast.success(`${template.title} added`);
  };

  // Delete widget
  const confirmDeleteWidget = () => {
    if (widgetToDelete) {
      const widgetName = layout.find(w => w.i === widgetToDelete)?.title || 'Widget';
      const newLayout = layout.filter(widget => widget.i !== widgetToDelete);
      setLayout(newLayout);
      setWidgetToDelete(null);
      saveLayout(newLayout);
      toast.success(`${widgetName} removed`);
    }
  };

  // Resize widget
  const handleWidgetResize = useCallback((widgetId: string, direction: 'increase' | 'decrease') => {
    const newLayout = layout.map(widget => {
      if (widget.i === widgetId) {
        const currentH = widget.h;
        const minH = widget.type === 'kpi' ? 2 : 3;
        const maxH = widget.type === 'kpi' ? 4 : 8;
        
        let newH = currentH;
        if (direction === 'increase' && currentH < maxH) {
          newH = currentH + 1;
        } else if (direction === 'decrease' && currentH > minH) {
          newH = currentH - 1;
        }
        
        if (newH !== currentH) {
          return { ...widget, h: newH };
        }
      }
      return widget;
    });
    if (JSON.stringify(newLayout) !== JSON.stringify(layout)) {
      setLayout(newLayout);
      saveLayout(newLayout);
    }
  }, [layout]);

  // Reset to default layout
  const resetToDefaultLayout = () => {
    setLayout(defaultLayout);
    saveLayout(defaultLayout);
    toast.success('Layout reset to default');
  };

  // Filter widgets by category
  const widgetCategories = ['all', ...Array.from(new Set(widgetCatalog.map(w => w.category)))];
  const filteredWidgetCatalog = selectedCategory === 'all' 
    ? widgetCatalog 
    : widgetCatalog.filter(w => w.category === selectedCategory);

  // Group widgets by category for display
  const groupedWidgets = useMemo(() => {
    const groups: Record<string, WidgetTemplate[]> = {};
    filteredWidgetCatalog.forEach(widget => {
      if (!groups[widget.category]) {
        groups[widget.category] = [];
      }
      groups[widget.category].push(widget);
    });
    return groups;
  }, [filteredWidgetCatalog]);

  // Render individual widget
  const renderWidget = (widget: Widget) => {
    switch (widget.type) {
      case 'kpi':
        return (
          <Card className="h-full border-border/50 shadow-sm">
            <CardContent className="p-6 flex flex-col justify-center h-full">
              <p className="text-sm font-medium text-muted-foreground mb-2">{widget.title}</p>
              <h3 className="text-4xl font-bold">$1.2M</h3>
            </CardContent>
          </Card>
        );
      
      case 'line-chart':
      case 'bar-chart':
      case 'pie-chart':
        return (
          <Card className="h-full border-border/50 shadow-sm">
            <CardHeader className="pb-2">
              <CardTitle className="text-base">{widget.title}</CardTitle>
            </CardHeader>
            <CardContent className="h-[calc(100%-4rem)]">
              {/* Implement your chart component here */}
              <div className="flex items-center justify-center h-full text-muted-foreground">
                Chart: {widget.dataSource}
              </div>
            </CardContent>
          </Card>
        );
      
      default:
        return null;
    }
  };

  return (
    <div className="p-6">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-2xl font-bold">Dashboard</h1>
        <div className="flex items-center gap-2">
          <Dialog open={addWidgetOpen} onOpenChange={setAddWidgetOpen}>
            <DialogTrigger asChild>
              <Button variant="outline" size="sm">
                <Plus className="h-4 w-4 mr-1" />
                Add Widget
              </Button>
            </DialogTrigger>
            <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
              <DialogHeader>
                <DialogTitle>Add Widget</DialogTitle>
                <DialogDescription>Choose a widget to add to your dashboard</DialogDescription>
              </DialogHeader>
              
              <div className="mb-4">
                <Select value={selectedCategory} onValueChange={setSelectedCategory}>
                  <SelectTrigger className="w-full">
                    <SelectValue placeholder="Filter by category" />
                  </SelectTrigger>
                  <SelectContent>
                    {widgetCategories.map(cat => (
                      <SelectItem key={cat} value={cat}>
                        {cat === 'all' ? 'All Categories' : cat}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-6">
                {Object.entries(groupedWidgets).map(([category, widgets]) => (
                  <div key={category}>
                    <h3 className="text-sm font-semibold text-muted-foreground mb-3 flex items-center gap-2">
                      <span className="h-px flex-1 bg-border" />
                      <span>{category}</span>
                      <span className="h-px flex-1 bg-border" />
                    </h3>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                      {widgets.map((template, index) => (
                        <Card 
                          key={`${category}-${index}`}
                          className="cursor-pointer hover:border-primary transition-colors"
                          onClick={() => addWidget(template)}
                        >
                          <CardContent className="p-3">
                            <div className="flex items-center gap-2">
                              <div className="p-1.5 bg-muted rounded">
                                <template.icon className="h-4 w-4 text-muted-foreground" />
                              </div>
                              <div className="flex-1 min-w-0">
                                <p className="font-medium text-sm truncate">{template.title}</p>
                                <p className="text-xs text-muted-foreground truncate">{template.description}</p>
                              </div>
                            </div>
                          </CardContent>
                        </Card>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </DialogContent>
          </Dialog>

          <Button variant="ghost" size="sm" onClick={resetToDefaultLayout}>
            <RotateCcw className="h-4 w-4 mr-1" />
            Reset
          </Button>
        </div>
      </div>

      {/* Grid Layout */}
      <div ref={containerRef}>
        <GridLayout
          className="layout"
          layout={layout}
          cols={cols}
          rowHeight={60}
          width={containerWidth}
          compactType="vertical"
          preventCollision={false}
          draggableHandle=".widget-drag-handle"
          onLayoutChange={onLayoutChange}
          isResizable={true}
          isDraggable={true}
        >
          {layout.map((widget) => (
            <div key={widget.i} className="relative group">
              {/* Widget Controls */}
              <div className="absolute top-2 right-2 z-10 flex items-center gap-1 opacity-60 hover:opacity-100 transition-opacity">
                <div 
                  className="widget-drag-handle h-7 w-7 flex items-center justify-center bg-background/95 rounded-l-md border border-r-0 border-border/50 cursor-grab active:cursor-grabbing"
                >
                  <GripVertical className="h-3.5 w-3.5 text-muted-foreground" />
                </div>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-7 w-7 bg-background/95 border border-l-0 border-r-0 border-border/50 hover:bg-muted rounded-none"
                  onClick={() => handleWidgetResize(widget.i, 'increase')}
                >
                  <Maximize2 className="h-3.5 w-3.5" />
                </Button>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-7 w-7 bg-background/95 border border-l-0 border-r-0 border-border/50 hover:bg-muted rounded-none"
                  onClick={() => handleWidgetResize(widget.i, 'decrease')}
                >
                  <Minimize2 className="h-3.5 w-3.5" />
                </Button>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-7 w-7 bg-background/95 rounded-l-none rounded-r-md border border-border/50 hover:bg-destructive/10 hover:text-destructive"
                  onClick={() => setWidgetToDelete(widget.i)}
                >
                  <X className="h-3.5 w-3.5" />
                </Button>
              </div>

              {/* Widget Content */}
              {renderWidget(widget)}
            </div>
          ))}
        </GridLayout>
      </div>

      {/* Delete Confirmation Dialog */}
      <AlertDialog open={!!widgetToDelete} onOpenChange={() => setWidgetToDelete(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Remove Widget</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to remove this widget from your dashboard? You can always add it back later.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={confirmDeleteWidget}>Remove</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
```

## Required CSS Styles

Add to your global CSS file:

```css
/* React Grid Layout - Touch-friendly resize handle */
.react-grid-item > .react-resizable-handle {
  position: absolute;
  width: 24px;
  height: 24px;
  bottom: 0;
  right: 0;
  cursor: se-resize;
  background: transparent;
  z-index: 10;
}

.react-grid-item > .react-resizable-handle::after {
  content: "";
  position: absolute;
  right: 4px;
  bottom: 4px;
  width: 12px;
  height: 12px;
  border-right: 3px solid hsl(var(--muted-foreground) / 0.4);
  border-bottom: 3px solid hsl(var(--muted-foreground) / 0.4);
  border-radius: 0 0 2px 0;
  transition: border-color 0.15s ease;
}

.react-grid-item > .react-resizable-handle:hover::after,
.react-grid-item > .react-resizable-handle:active::after {
  border-color: hsl(var(--primary));
}

/* Larger touch target on mobile */
@media (max-width: 768px) {
  .react-grid-item > .react-resizable-handle {
    width: 32px;
    height: 32px;
  }
  
  .react-grid-item > .react-resizable-handle::after {
    right: 6px;
    bottom: 6px;
    width: 14px;
    height: 14px;
    border-width: 3px;
  }
}
```

## Backend API for Persistence

Example API endpoints needed:

```typescript
// GET /api/preferences
// Returns: { dashboardLayout: Widget[] }

// PUT /api/preferences
// Body: { dashboardLayout: Widget[] }
// Returns: { dashboardLayout: Widget[] }
```

## Key Features Explained

### 1. Drag and Drop
- Uses `react-grid-layout` with `draggableHandle=".widget-drag-handle"`
- Only the grip icon is draggable, preventing accidental moves
- Auto-scrolling when dragging near viewport edges

### 2. Resize
- Built-in `react-grid-layout` resize handles (bottom-right corner)
- Custom resize buttons (Maximize/Minimize) for height adjustment
- Min/max constraints based on widget type

### 3. Add Widgets
- Modal dialog with categorized widget catalog
- Search/filter by category
- Click to add instantly to bottom of dashboard

### 4. Remove Widgets
- X button on each widget
- Confirmation dialog before deletion
- Toast notification on success

### 5. Persistence
- Layout saved to localStorage and/or backend
- Debounced saves to prevent excessive API calls
- Loads saved layout on component mount

### 6. Responsive Design
- Mobile (8 columns): Single column, vertical stacking
- Tablet (16 columns): 2-column layout for KPIs
- Desktop (24 columns): Full grid flexibility

## Advanced Enhancements

### Auto-save with Debounce

```typescript
import { useDebounce } from '@/hooks/useDebounce';

const debouncedLayout = useDebounce(layout, 500);

useEffect(() => {
  if (debouncedLayout.length > 0) {
    saveLayout(debouncedLayout);
  }
}, [debouncedLayout]);
```

### Layout Presets

```typescript
const layoutPresets = {
  default: defaultLayout,
  executive: [...],
  sales: [...],
  analytics: [...],
};

const applyPreset = (presetName: string) => {
  setLayout(layoutPresets[presetName]);
};
```

### Widget Data Refresh

```typescript
const { data: widgetData } = useQuery({
  queryKey: ['widget-data', widget.dataSource],
  queryFn: () => fetchWidgetData(widget.dataSource),
  refetchInterval: 30000, // 30 seconds
});
```

## Testing Checklist

- [ ] Drag widgets to new positions
- [ ] Resize widgets using corner handle
- [ ] Resize using +/- buttons
- [ ] Add widget from catalog
- [ ] Remove widget with confirmation
- [ ] Reset to default layout
- [ ] Layout persists on page reload
- [ ] Responsive behavior on mobile
- [ ] Responsive behavior on tablet
- [ ] Multiple widgets can coexist
- [ ] No widget overlap issues

## Screenshot Reference

The implementation should look like this:

![Dashboard Grid Layout](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwMCIgaGVpZ2h0PSI4MDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHJlY3Qgd2lkdGg9IjEyMDAiIGhlaWdodD0iODAwIiBmaWxsPSIjZjlmYWZiIi8+CiAgPCEtLSBIZWFkZXIgLS0+CiAgPHJlY3QgeD0iMjAiIHk9IjIwIiB3aWR0aD0iMTIwIiBoZWlnaHQ9IjQwIiBmaWxsPSIjMzMzIiByeD0iNCIvPgogIDx0ZXh0IHg9IjE1MCIgeT0iNDUiIGZpbGw9IiMzMzMiIGZvbnQtc2l6ZT0iMjQiIGZvbnQtd2VpZ2h0PSJib2xkIj5EYXNoYm9hcmQ8L3RleHQ+CiAgPHJlY3QgeD0iMTAwMCIgeT0iMjAiIHdpZHRoPSI5MCIgaGVpZ2h0PSI0MCIgZmlsbD0iIzM3ODZmZiIgcng9IjQiLz4KICA8dGV4dCB4PSIxMDE1IiB5PSI0NSIgZmlsbD0id2hpdGUiIGZvbnQtc2l6ZT0iMTQiPkFkZCBXaWRnZXQ8L3RleHQ+CiAgCiAgPCEtLSBLUEkgV2lkZ2V0cyAtLT4KICA8cmVjdCB4PSIyMCIgeT0iODAiIHdpZHRoPSIzODAiIGhlaWdodD0iMTIwIiBmaWxsPSJ3aGl0ZSIgc3Ryb2tlPSIjZTBlN2ZmIiBzdHJva2Utd2lkdGg9IjIiIHJ4PSI4Ii8+CiAgPGNpcmNsZSBjeD0iMzgwIiBjeT0iMTAwIiByPSIxMiIgZmlsbD0iI2Y5ZmFmYiIgc3Ryb2tlPSIjZTBlN2ZmIi8+CiAgPHRleHQgeD0iNDAiIHk9IjExMCIgZmlsbD0iIzY2NiIgZm9udC1zaXplPSIxMiI+VG90YWwgUmV2ZW51ZTwvdGV4dD4KICA8dGV4dCB4PSI0MCIgeT0iMTU1IiBmaWxsPSIjMzMzIiBmb250LXNpemU9IjMyIiBmb250LXdlaWdodD0iYm9sZCI+JDEuMk08L3RleHQ+CiAgCiAgPHJlY3QgeD0iNDIwIiB5PSI4MCIgd2lkdGg9IjM4MCIgaGVpZ2h0PSIxMjAiIGZpbGw9IndoaXRlIiBzdHJva2U9IiNlMGU3ZmYiIHN0cm9rZS13aWR0aD0iMiIgcng9IjgiLz4KICA8dGV4dCB4PSI0NDAiIHk9IjExMCIgZmlsbD0iIzY2NiIgZm9udC1zaXplPSIxMiI+QWN0aXZlIFVzZXJzPC90ZXh0PgogIDx0ZXh0IHg9IjQ0MCIgeT0iMTU1IiBmaWxsPSIjMzMzIiBmb250LXNpemU9IjMyIiBmb250LXdlaWdodD0iYm9sZCI+MiwzNDU8L3RleHQ+CiAgCiAgPCEtLSBDaGFydCBXaWRnZXQgLS0+CiAgPHJlY3QgeD0iMjAiIHk9IjIyMCIgd2lkdGg9Ijc4MCIgaGVpZ2h0PSIyNDAiIGZpbGw9IndoaXRlIiBzdHJva2U9IiNlMGU3ZmYiIHN0cm9rZS13aWR0aD0iMiIgcng9IjgiLz4KICA8dGV4dCB4PSI0MCIgeT0iMjUwIiBmaWxsPSIjMzMzIiBmb250LXNpemU9IjE2IiBmb250LXdlaWdodD0iYm9sZCI+UmV2ZW51ZSBUcmVuZDwvdGV4dD4KICA8cG9seWxpbmUgcG9pbnRzPSI2MCwyODAgMTUwLDM1MCAyNDAsMzAwIDMzMCwyNjAgNDIwLDMxMCA1MTAsMjcwIDYwMCwzMjAgNjkwLDI4MCIgc3Ryb2tlPSIjMzc4NmZmIiBzdHJva2Utd2lkdGg9IjMiIGZpbGw9Im5vbmUiLz4KICAKICA8IS0tIERyYWcgSGFuZGxlIEluZGljYXRvcnMgLS0+CiAgPGNpcmNsZSBjeD0iNzgwIiBjeT0iMTAwIiByPSI2IiBmaWxsPSIjOTk5Ii8+CiAgPGNpcmNsZSBjeD0iNzgwIiBjeT0iMTE1IiByPSI2IiBmaWxsPSIjOTk5Ii8+CiAgPGNpcmNsZSBjeD0iNzgwIiBjeT0iMTMwIiByPSI2IiBmaWxsPSIjOTk5Ii8+Cjwvc3ZnPgo=)

**Key Visual Elements:**
1. Header with "Add Widget" button and "Reset" button
2. KPI cards with large numbers and drag handles
3. Chart widgets with titles and visualization area
4. Hover controls (grip, resize, delete) in top-right of each widget
5. Clean spacing and borders
6. Responsive grid that adapts to screen size

## Implementation Notes

1. **Start with the grid container** - Set up `react-grid-layout` first
2. **Add basic widgets** - Implement KPI and one chart type
3. **Add controls** - Drag handles, resize buttons, delete buttons
4. **Implement persistence** - Save/load layout from API
5. **Add widget catalog** - Dialog for adding new widgets
6. **Polish responsive** - Test on mobile, tablet, desktop
7. **Add data integration** - Connect widgets to real data sources

This implementation provides a fully functional, production-ready dashboard grid system with all adjustability features.